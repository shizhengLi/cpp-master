# C++协程与异步编程范式：高并发时代的编程革命

## 引言：从回调地狱到结构化并发

C++20引入的协程是异步编程的重大突破，它将复杂的异步操作转化为看起来像同步代码的结构化写法，彻底改变了我们处理并发的方式。

```cpp
// 传统的异步回调方式
void traditional_async() {
    fetch_data("url", [](const std::string& data) {
        parse_json(data, [](const JsonValue& json) {
            process_result(json, [](const Result& result) {
                // 嵌套的回调地狱
                std::cout << result << std::endl;
            });
        });
    });
}

// C++20协程方式
Task<std::string> modern_async() {
    auto data = co_await fetch_data("url");
    auto json = co_await parse_json(data);
    auto result = co_await process_result(json);
    co_return result;
}
```

## 协程的基础概念

### 1. 协程的核心机制

协程是一种可以暂停和恢复的函数，它通过三个关键字实现：`co_await`、`co_return`、`co_yield`。

```cpp
// 协程的基本结构
Task<int> simple_coroutine() {
    std::cout << "Start coroutine\n";

    // co_await：暂停协程，等待异步操作完成
    co_await std::suspend_always{};

    std::cout << "Resumed after suspension\n";

    // co_return：返回值
    co_return 42;
}

// 协程的执行流程
void coroutine_execution_flow() {
    auto task = simple_coroutine();
    std::cout << "Coroutine created but not started\n";

    // 恢复协程执行
    task.resume();

    std::cout << "Coroutine suspended\n";

    // 再次恢复协程
    task.resume();

    std::cout << "Coroutine completed with result: " << task.get_result() << std::endl;
}
```

### 2. 协程状态机

协程的底层实现是一个状态机，每个暂停点对应一个状态。

```cpp
// 协程状态机的示意实现
class CoroutineStateMachine {
private:
    enum class State {
        Created,
        Started,
        Suspended1,
        Suspended2,
        Completed
    };

    State state = State::Created;
    int result = 0;

public:
    bool resume() {
        switch (state) {
            case State::Created:
                std::cout << "Starting coroutine\n";
                state = State::Started;
                return true; // 继续执行

            case State::Started:
                std::cout << "First suspension point\n";
                state = State::Suspended1;
                return false; // 暂停

            case State::Suspended1:
                std::cout << "Second suspension point\n";
                state = State::Suspended2;
                return false; // 暂停

            case State::Suspended2:
                std::cout << "Completing coroutine\n";
                result = 42;
                state = State::Completed;
                return false; // 完成

            case State::Completed:
                return false; // 已完成
        }
    }

    int get_result() const { return result; }
    bool is_done() const { return state == State::Completed; }
};
```

## 协程的类型与Promise对象

### 1. 协程返回类型

C++协程的返回类型必须满足特定的要求，通常是一个包含promise_type的类型。

```cpp
// 自定义协程返回类型
template<typename T>
class Task {
public:
    struct promise_type {
        T value;
        std::exception_ptr exception;

        Task get_return_object() {
            return Task{std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }

        void return_value(T v) { value = std::move(v); }
        void unhandled_exception() { exception = std::current_exception(); }
    };

private:
    std::coroutine_handle<promise_type> handle;

public:
    Task(std::coroutine_handle<promise_type> h) : handle(h) {}
    ~Task() {
        if (handle) handle.destroy();
    }

    Task(const Task&) = delete;
    Task& operator=(const Task&) = delete;

    Task(Task&& other) noexcept : handle(other.handle) {
        other.handle = nullptr;
    }

    Task& operator=(Task&& other) noexcept {
        if (this != &other) {
            if (handle) handle.destroy();
            handle = other.handle;
            other.handle = nullptr;
        }
        return *this;
    }

    bool await_ready() const { return false; }
    void await_suspend(std::coroutine_handle<> awaiting) {
        handle.promise().awaiting = awaiting;
    }
    T await_resume() {
        if (handle.promise().exception) {
            std::rethrow_exception(handle.promise().exception);
        }
        return std::move(handle.promise().value);
    }

    T get_result() {
        handle.resume();
        if (handle.promise().exception) {
            std::rethrow_exception(handle.promise().exception);
        }
        return std::move(handle.promise().value);
    }
};
```

### 2. Promise对象的作用

Promise对象管理协程的状态、返回值和异常。

```cpp
// 详细的Promise对象实现
class AdvancedPromise {
private:
    std::optional<T> result;
    std::exception_ptr exception;
    std::coroutine_handle<> awaiting_coroutine;
    std::function<void(T)> continuation;
    std::atomic<bool> completed = false;

public:
    // 协程开始时的行为
    auto initial_suspend() {
        return std::suspend_always{};
    }

    // 协程结束时的行为
    auto final_suspend() noexcept {
        struct FinalAwaiter {
            bool await_ready() noexcept { return false; }

            void await_suspend(std::coroutine_handle<promise_type> h) noexcept {
                if (h.promise().awaiting_coroutine) {
                    h.promise().awaiting_coroutine.resume();
                }

                if (h.promise().continuation) {
                    h.promise().continuation(h.promise().result.value());
                }
            }

            void await_resume() noexcept {}
        };

        return FinalAwaiter{};
    }

    // 处理返回值
    void return_value(T value) {
        result = std::move(value);
        completed = true;
    }

    // 处理异常
    void unhandled_exception() {
        exception = std::current_exception();
        completed = true;
    }

    // 获取返回对象
    Task<T> get_return_object() {
        return Task<T>{std::coroutine_handle<promise_type>::from_promise(*this)};
    }

    // 设置继续执行函数
    void set_continuation(std::function<void(T)> func) {
        continuation = std::move(func);
    }

    // 检查是否完成
    bool is_completed() const {
        return completed.load();
    }
};
```

## 异步操作的实现

### 1. 基于协程的异步IO

```cpp
// 异步文件读取的协程实现
class AsyncFile {
private:
    int file_descriptor;
    std::string filename;

public:
    AsyncFile(const std::string& name) : filename(name) {
        // 打开文件
        file_descriptor = open(name.c_str(), O_RDONLY);
        if (file_descriptor == -1) {
            throw std::runtime_error("Failed to open file");
        }
    }

    ~AsyncFile() {
        if (file_descriptor != -1) {
            close(file_descriptor);
        }
    }

    // 异步读取
    Task<std::string> read_async(size_t size) {
        std::string buffer(size, '\0');

        // 使用libaio进行异步IO
        struct iocb cb;
        struct io_event events[1];
        io_context_t ctx = 0;

        io_setup(1, &ctx);

        memset(&cb, 0, sizeof(cb));
        cb.aio_fildes = file_descriptor;
        cb.aio_buf = reinterpret_cast<uint64_t>(buffer.data());
        cb.aio_nbytes = size;
        cb.aio_lio_opcode = IO_CMD_PREAD;

        // 提交异步IO请求
        io_submit(ctx, 1, &cb);

        // 等待IO完成
        io_getevents(ctx, 1, 1, events, nullptr);

        io_destroy(ctx);

        co_return buffer;
    }

    // 异步写入
    Task<size_t> write_async(const std::string& data) {
        struct iocb cb;
        struct io_event events[1];
        io_context_t ctx = 0;

        io_setup(1, &ctx);

        memset(&cb, 0, sizeof(cb));
        cb.aio_fildes = file_descriptor;
        cb.aio_buf = reinterpret_cast<uint64_t>(data.data());
        cb.aio_nbytes = data.size();
        cb.aio_lio_opcode = IO_CMD_PWRITE;

        io_submit(ctx, 1, &cb);
        io_getevents(ctx, 1, 1, events, nullptr);

        io_destroy(ctx);

        co_return events[0].res;
    }
};

// 使用异步文件操作
Task<void> process_file_async() {
    AsyncFile file("data.txt");

    // 异步读取
    auto content = co_await file.read_async(1024);
    std::cout << "Read content: " << content << std::endl;

    // 处理数据
    std::transform(content.begin(), content.end(), content.begin(), ::toupper);

    // 异步写入
    auto bytes_written = co_await file.write_async(content);
    std::cout << "Written " << bytes_written << " bytes" << std::endl;
}
```

### 2. 网络编程中的协程

```cpp
// 异步网络客户端
class AsyncHttpClient {
private:
    std::string host;
    int port;
    int socket_fd;

public:
    AsyncHttpClient(const std::string& h, int p) : host(h), port(p) {}

    // 异步连接
    Task<void> connect_async() {
        socket_fd = socket(AF_INET, SOCK_STREAM, 0);
        if (socket_fd == -1) {
            throw std::runtime_error("Failed to create socket");
        }

        // 设置非阻塞模式
        int flags = fcntl(socket_fd, F_GETFL, 0);
        fcntl(socket_fd, F_SETFL, flags | O_NONBLOCK);

        struct sockaddr_in server_addr;
        memset(&server_addr, 0, sizeof(server_addr));
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(port);

        // 解析主机名
        struct hostent* host_entry = gethostbyname(host.c_str());
        if (!host_entry) {
            throw std::runtime_error("Failed to resolve hostname");
        }

        memcpy(&server_addr.sin_addr, host_entry->h_addr_list[0], host_entry->h_length);

        // 异步连接
        int result = connect(socket_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));

        if (result == -1 && errno != EINPROGRESS) {
            throw std::runtime_error("Failed to connect");
        }

        // 等待连接建立
        fd_set write_fds;
        FD_ZERO(&write_fds);
        FD_SET(socket_fd, &write_fds);

        struct timeval timeout;
        timeout.tv_sec = 10;
        timeout.tv_usec = 0;

        result = select(socket_fd + 1, nullptr, &write_fds, nullptr, &timeout);

        if (result == -1) {
            throw std::runtime_error("Select failed");
        } else if (result == 0) {
            throw std::runtime_error("Connection timeout");
        }

        int error = 0;
        socklen_t len = sizeof(error);
        if (getsockopt(socket_fd, SOL_SOCKET, SO_ERROR, &error, &len) == -1) {
            throw std::runtime_error("Failed to get socket error");
        }

        if (error != 0) {
            throw std::runtime_error("Connection failed");
        }

        co_return;
    }

    // 异步发送HTTP请求
    Task<std::string> send_request_async(const std::string& request) {
        size_t total_sent = 0;
        const char* data = request.c_str();
        size_t data_size = request.size();

        while (total_sent < data_size) {
            ssize_t sent = send(socket_fd, data + total_sent, data_size - total_sent, 0);

            if (sent == -1) {
                if (errno == EAGAIN || errno == EWOULDBLOCK) {
                    // 等待socket可写
                    fd_set write_fds;
                    FD_ZERO(&write_fds);
                    FD_SET(socket_fd, &write_fds);

                    select(socket_fd + 1, nullptr, &write_fds, nullptr, nullptr);
                    continue;
                } else {
                    throw std::runtime_error("Send failed");
                }
            }

            total_sent += sent;
        }

        // 异步接收响应
        std::string response;
        char buffer[4096];

        while (true) {
            ssize_t received = recv(socket_fd, buffer, sizeof(buffer), 0);

            if (received == -1) {
                if (errno == EAGAIN || errno == EWOULDBLOCK) {
                    // 等待socket可读
                    fd_set read_fds;
                    FD_ZERO(&read_fds);
                    FD_SET(socket_fd, &read_fds);

                    select(socket_fd + 1, &read_fds, nullptr, nullptr, nullptr);
                    continue;
                } else {
                    throw std::runtime_error("Receive failed");
                }
            } else if (received == 0) {
                break; // 连接关闭
            }

            response.append(buffer, received);

            // 检查是否接收完HTTP响应
            if (response.find("\r\n\r\n") != std::string::npos) {
                size_t header_end = response.find("\r\n\r\n");
                std::string headers = response.substr(0, header_end);

                // 解析Content-Length
                size_t content_length_pos = headers.find("Content-Length: ");
                if (content_length_pos != std::string::npos) {
                    size_t line_end = headers.find("\r\n", content_length_pos);
                    std::string content_length_str = headers.substr(
                        content_length_pos + 16, line_end - content_length_pos - 16);

                    int content_length = std::stoi(content_length_str);
                    size_t current_size = response.size() - header_end - 4;

                    if (current_size >= content_length) {
                        break;
                    }
                }
            }
        }

        co_return response;
    }
};

// 使用异步HTTP客户端
Task<std::string> fetch_url_async(const std::string& url) {
    // 解析URL
    std::string host = "example.com";
    int port = 80;
    std::string path = "/";

    AsyncHttpClient client(host, port);

    // 异步连接
    co_await client.connect_async();

    // 构造HTTP请求
    std::string request = "GET " + path + " HTTP/1.1\r\n" +
                         "Host: " + host + "\r\n" +
                         "Connection: close\r\n" +
                         "\r\n";

    // 异步发送请求并获取响应
    auto response = co_await client.send_request_async(request);

    co_return response;
}
```

## 高级协程技术

### 1. 协程调度器

```cpp
// 协程调度器的实现
class CoroutineScheduler {
private:
    std::queue<std::coroutine_handle<>> ready_coroutines;
    std::vector<std::coroutine_handle<>> waiting_coroutines;
    std::mutex mutex;
    std::condition_variable cv;
    std::atomic<bool> running = false;
    std::vector<std::thread> worker_threads;

public:
    CoroutineScheduler(size_t thread_count = std::thread::hardware_concurrency()) {
        running = true;

        for (size_t i = 0; i < thread_count; ++i) {
            worker_threads.emplace_back([this]() {
                while (running) {
                    std::coroutine_handle<> coroutine;

                    {
                        std::unique_lock<std::mutex> lock(mutex);
                        cv.wait(lock, [this]() {
                            return !ready_coroutines.empty() || !running;
                        });

                        if (!running && ready_coroutines.empty()) {
                            return;
                        }

                        coroutine = ready_coroutines.front();
                        ready_coroutines.pop();
                    }

                    if (coroutine) {
                        coroutine.resume();

                        if (!coroutine.done()) {
                            std::unique_lock<std::mutex> lock(mutex);
                            ready_coroutines.push(coroutine);
                        } else {
                            coroutine.destroy();
                        }
                    }
                }
            });
        }
    }

    ~CoroutineScheduler() {
        running = false;
        cv.notify_all();

        for (auto& thread : worker_threads) {
            thread.join();
        }
    }

    // 提交协程到调度器
    void schedule(std::coroutine_handle<> coroutine) {
        std::unique_lock<std::mutex> lock(mutex);
        ready_coroutines.push(coroutine);
        cv.notify_one();
    }

    // 获取调度器实例
    static CoroutineScheduler& get_instance() {
        static CoroutineScheduler instance;
        return instance;
    }
};

// 支持调度的协程Awaiter
struct ScheduleAwaiter {
    bool await_ready() const { return false; }

    void await_suspend(std::coroutine_handle<> coroutine) {
        CoroutineScheduler::get_instance().schedule(coroutine);
    }

    void await_resume() {}
};

// 在调度器上执行协程
Task<void> scheduled_coroutine() {
    std::cout << "Coroutine started on thread " << std::this_thread::get_id() << std::endl;

    // 让出控制权，让其他协程执行
    co_await ScheduleAwaiter{};

    std::cout << "Coroutine resumed on thread " << std::this_thread::get_id() << std::endl;

    co_await ScheduleAwaiter{};

    std::cout << "Coroutine completed on thread " << std::this_thread::get_id() << std::endl;
}
```

### 2. 协程与并发控制

```cpp
// 协程互斥锁
class CoroutineMutex {
private:
    std::queue<std::coroutine_handle<>> waiting_coroutines;
    bool locked = false;

public:
    struct LockAwaiter {
        CoroutineMutex& mutex;

        bool await_ready() const { return !mutex.locked; }

        bool await_suspend(std::coroutine_handle<> coroutine) {
            mutex.waiting_coroutines.push(coroutine);
            return true;
        }

        void await_resume() {}
    };

    LockAwaiter lock() {
        return LockAwaiter{*this};
    }

    void unlock() {
        locked = false;
        if (!waiting_coroutines.empty()) {
            auto next = waiting_coroutines.front();
            waiting_coroutines.pop();
            next.resume();
        }
    }
};

// 协程信号量
class CoroutineSemaphore {
private:
    int counter;
    std::queue<std::coroutine_handle<>> waiting_coroutines;

public:
    CoroutineSemaphore(int initial_count) : counter(initial_count) {}

    struct AcquireAwaiter {
        CoroutineSemaphore& semaphore;

        bool await_ready() const { return semaphore.counter > 0; }

        bool await_suspend(std::coroutine_handle<> coroutine) {
            semaphore.waiting_coroutines.push(coroutine);
            return true;
        }

        void await_resume() {}
    };

    AcquireAwaiter acquire() {
        return AcquireAwaiter{*this};
    }

    void release() {
        counter++;
        if (!waiting_coroutines.empty()) {
            auto next = waiting_coroutines.front();
            waiting_coroutines.pop();
            counter--;
            next.resume();
        }
    }
};

// 使用协程同步原语
Task<void> concurrent_processing() {
    CoroutineSemaphore semaphore(3); // 限制并发数为3

    std::vector<Task<void>> tasks;

    for (int i = 0; i < 10; ++i) {
        tasks.push_back([i, &semaphore]() -> Task<void> {
            // 获取信号量
            co_await semaphore.acquire();

            try {
                std::cout << "Processing task " << i << " on thread "
                          << std::this_thread::get_id() << std::endl;

                // 模拟耗时操作
                co_await ScheduleAwaiter{};

                std::cout << "Completed task " << i << std::endl;
            } catch (...) {
                semaphore.release();
                throw;
            }

            semaphore.release();
        }());
    }

    // 等待所有任务完成
    for (auto& task : tasks) {
        co_await task;
    }
}
```

### 3. 协程与算法

```cpp
// 协程生成器
template<typename T>
class Generator {
public:
    struct promise_type {
        T current_value;
        std::exception_ptr exception;

        Generator get_return_object() {
            return Generator{std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }

        void return_void() {}
        void unhandled_exception() { exception = std::current_exception(); }

        std::suspend_always yield_value(T value) {
            current_value = std::move(value);
            return {};
        }
    };

private:
    std::coroutine_handle<promise_type> handle;

public:
    Generator(std::coroutine_handle<promise_type> h) : handle(h) {}
    ~Generator() {
        if (handle) handle.destroy();
    }

    Generator(const Generator&) = delete;
    Generator& operator=(const Generator&) = delete;

    Generator(Generator&& other) noexcept : handle(other.handle) {
        other.handle = nullptr;
    }

    Generator& operator=(Generator&& other) noexcept {
        if (this != &other) {
            if (handle) handle.destroy();
            handle = other.handle;
            other.handle = nullptr;
        }
        return *this;
    }

    struct Iterator {
        std::coroutine_handle<promise_type> handle;

        Iterator& operator++() {
            handle.resume();
            return *this;
        }

        const T& operator*() const {
            return handle.promise().current_value;
        }

        bool operator!=(const Iterator& other) const {
            return handle != other.handle;
        }
    };

    Iterator begin() {
        handle.resume();
        return Iterator{handle};
    }

    Iterator end() {
        return Iterator{nullptr};
    }
};

// 斐波那契数列生成器
Generator<int> fibonacci_generator() {
    int a = 0, b = 1;

    while (true) {
        co_yield a;
        int temp = a + b;
        a = b;
        b = temp;
    }
}

// 使用生成器
Task<void> use_fibonacci() {
    auto fib = fibonacci_generator();

    for (int i = 0; i < 10; ++i) {
        std::cout << co_await fib << " ";
    }
    std::cout << std::endl;
}

// 异步算法：并行归并排序
template<typename Iterator>
Task<void> parallel_merge_sort(Iterator begin, Iterator end, int depth = 0) {
    if (end - begin <= 1) {
        co_return;
    }

    if (depth > 3) { // 限制递归深度
        std::sort(begin, end);
        co_return;
    }

    Iterator mid = begin + (end - begin) / 2;

    // 并行排序两个子数组
    auto left_task = parallel_merge_sort(begin, mid, depth + 1);
    auto right_task = parallel_merge_sort(mid, end, depth + 1);

    co_await left_task;
    co_await right_task;

    // 合并排序结果
    std::inplace_merge(begin, mid, end);
}
```

## 性能优化与最佳实践

### 1. 协程的内存管理

```cpp
// 协程内存池优化
class CoroutineMemoryPool {
private:
    static constexpr size_t POOL_SIZE = 1024;
    static constexpr size_t BLOCK_SIZE = 4096;

    std::vector<void*> free_blocks;
    std::mutex pool_mutex;

public:
    void* allocate(size_t size) {
        if (size > BLOCK_SIZE) {
            return operator new(size);
        }

        std::unique_lock<std::mutex> lock(pool_mutex);

        if (free_blocks.empty()) {
            return operator new(BLOCK_SIZE);
        }

        void* block = free_blocks.back();
        free_blocks.pop_back();
        return block;
    }

    void deallocate(void* ptr) {
        // 简化版本，实际需要知道分配的大小
        std::unique_lock<std::mutex> lock(pool_mutex);
        free_blocks.push_back(ptr);
    }

    static CoroutineMemoryPool& get_instance() {
        static CoroutineMemoryPool instance;
        return instance;
    }
};

// 使用内存池的Promise
template<typename T>
class PoolAwareTask {
public:
    struct promise_type {
        void* operator new(size_t size) {
            return CoroutineMemoryPool::get_instance().allocate(size);
        }

        void operator delete(void* ptr) {
            CoroutineMemoryPool::get_instance().deallocate(ptr);
        }

        // ... 其他promise方法
    };

    // ... Task的其他实现
};
```

### 2. 协程与缓存友好性

```cpp
// 缓存友好的协程批处理
class CoroutineBatchProcessor {
private:
    static constexpr size_t BATCH_SIZE = 64;
    std::vector<std::coroutine_handle<>> batch;

public:
    template<typename Func>
    void process_batch(Func&& func) {
        for (auto& coroutine : batch) {
            if (coroutine && !coroutine.done()) {
                func(coroutine);
            }
        }
        batch.clear();
    }

    void add_coroutine(std::coroutine_handle<> coroutine) {
        if (batch.size() < BATCH_SIZE) {
            batch.push_back(coroutine);
        } else {
            process_batch([](auto& coro) { coro.resume(); });
            batch.push_back(coroutine);
        }
    }

    void flush() {
        process_batch([](auto& coro) { coro.resume(); });
    }
};

// 数据局部性优化
template<typename T>
class LocalityOptimizedTask {
public:
    struct promise_type {
        alignas(64) T value; // 缓存行对齐
        std::exception_ptr exception;

        // 确保promise对象在单独的缓存行
        char padding[64 - sizeof(T) - sizeof(std::exception_ptr)];

        // ... 其他promise方法
    };

    // ... Task的其他实现
};
```

### 3. 错误处理与调试

```cpp
// 协程错误处理
template<typename T>
class ErrorHandlingTask {
public:
    struct promise_type {
        std::variant<T, std::exception_ptr> result;

        void return_value(T value) {
            result = std::move(value);
        }

        void unhandled_exception() {
            result = std::current_exception();
        }

        // ... 其他promise方法
    };

    // 增强的await_suspend，包含错误处理
    bool await_suspend(std::coroutine_handle<> awaiting) {
        try {
            // 正常的await_suspend逻辑
            return true;
        } catch (...) {
            // 处理异常
            return false;
        }
    }

    T await_resume() {
        if (std::holds_alternative<std::exception_ptr>(result)) {
            std::rethrow_exception(std::get<std::exception_ptr>(result));
        }
        return std::get<T>(result);
    }
};

// 协程调试支持
class CoroutineDebugger {
private:
    static std::unordered_map<std::coroutine_handle<>, std::string> coroutine_names;
    static std::mutex debug_mutex;

public:
    static void register_coroutine(std::coroutine_handle<> handle,
                                 const std::string& name) {
        std::unique_lock<std::mutex> lock(debug_mutex);
        coroutine_names[handle] = name;
    }

    static void unregister_coroutine(std::coroutine_handle<> handle) {
        std::unique_lock<std::mutex> lock(debug_mutex);
        coroutine_names.erase(handle);
    }

    static std::string get_coroutine_name(std::coroutine_handle<> handle) {
        std::unique_lock<std::mutex> lock(debug_mutex);
        auto it = coroutine_names.find(handle);
        return it != coroutine_names.end() ? it->second : "unknown";
    }

    static void dump_active_coroutines() {
        std::unique_lock<std::mutex> lock(debug_mutex);
        std::cout << "Active coroutines:\n";
        for (const auto& [handle, name] : coroutine_names) {
            std::cout << "  " << name << " at " << handle.address() << "\n";
        }
    }
};
```

## 实际应用案例

### 1. Web服务器中的协程应用

```cpp
// 基于协程的HTTP服务器
class CoroutineHttpServer {
private:
    int server_socket;
    CoroutineScheduler scheduler;
    bool running = false;

public:
    CoroutineHttpServer(int port) {
        server_socket = socket(AF_INET, SOCK_STREAM, 0);
        if (server_socket == -1) {
            throw std::runtime_error("Failed to create server socket");
        }

        int opt = 1;
        setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

        struct sockaddr_in server_addr;
        memset(&server_addr, 0, sizeof(server_addr));
        server_addr.sin_family = AF_INET;
        server_addr.sin_addr.s_addr = INADDR_ANY;
        server_addr.sin_port = htons(port);

        if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
            throw std::runtime_error("Failed to bind server socket");
        }

        if (listen(server_socket, 128) == -1) {
            throw std::runtime_error("Failed to listen on server socket");
        }
    }

    Task<void> handle_client(int client_socket) {
        try {
            char buffer[4096];
            std::string request;

            while (true) {
                ssize_t bytes_read = recv(client_socket, buffer, sizeof(buffer), 0);
                if (bytes_read <= 0) break;

                request.append(buffer, bytes_read);

                if (request.find("\r\n\r\n") != std::string::npos) {
                    break;
                }
            }

            // 解析HTTP请求
            std::string response = "HTTP/1.1 200 OK\r\n"
                                  "Content-Type: text/plain\r\n"
                                  "Connection: close\r\n"
                                  "\r\n"
                                  "Hello from coroutine server!\n";

            send(client_socket, response.c_str(), response.size(), 0);

        } catch (const std::exception& e) {
            std::cerr << "Error handling client: " << e.what() << std::endl;
        }

        close(client_socket);
    }

    Task<void> accept_connections() {
        while (running) {
            struct sockaddr_in client_addr;
            socklen_t client_len = sizeof(client_addr);

            int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_len);
            if (client_socket == -1) {
                if (errno == EAGAIN || errno == EWOULDBLOCK) {
                    co_await ScheduleAwaiter{};
                    continue;
                } else {
                    throw std::runtime_error("Failed to accept connection");
                }
            }

            // 设置非阻塞模式
            int flags = fcntl(client_socket, F_GETFL, 0);
            fcntl(client_socket, F_SETFL, flags | O_NONBLOCK);

            // 启动客户端处理协程
            handle_client(client_socket);
        }
    }

    void start() {
        running = true;

        // 设置服务器socket为非阻塞
        int flags = fcntl(server_socket, F_GETFL, 0);
        fcntl(server_socket, F_SETFL, flags | O_NONBLOCK);

        // 启动接受连接的协程
        accept_connections();
    }

    void stop() {
        running = false;
        close(server_socket);
    }
};
```

### 2. 游戏引擎中的协程应用

```cpp
// 游戏引擎的协程系统
class GameCoroutineSystem {
private:
    std::vector<std::coroutine_handle<>> active_coroutines;
    std::vector<std::coroutine_handle<>> waiting_coroutines;
    float current_time = 0.0f;

public:
    // 等待指定时间
    struct WaitForSeconds {
        float duration;

        bool await_ready() const { return false; }

        bool await_suspend(std::coroutine_handle<> coroutine) {
            return true;
        }

        void await_resume() {}
    };

    // 等待直到条件满足
    template<typename Predicate>
    struct WaitUntil {
        Predicate predicate;
        float check_interval = 0.1f;

        bool await_ready() const { return predicate(); }

        bool await_suspend(std::coroutine_handle<> coroutine) {
            return true;
        }

        void await_resume() {}
    };

    // 更新协程系统
    void update(float delta_time) {
        current_time += delta_time;

        // 处理等待时间的协程
        for (auto it = waiting_coroutines.begin(); it != waiting_coroutines.end();) {
            // 检查等待条件是否满足
            bool should_resume = false;

            // 这里简化处理，实际需要更复杂的逻辑
            it->resume();

            if (it->done()) {
                it->destroy();
                it = waiting_coroutines.erase(it);
            } else {
                ++it;
            }
        }

        // 处理活动协程
        for (auto it = active_coroutines.begin(); it != active_coroutines.end();) {
            it->resume();

            if (it->done()) {
                it->destroy();
                it = active_coroutines.erase(it);
            } else {
                ++it;
            }
        }
    }

    // 启动游戏协程
    template<typename Coroutine>
    void start_coroutine(Coroutine&& coroutine) {
        active_coroutines.push_back(coroutine.handle);
    }
};

// 游戏AI行为协程
Task<void> enemy_ai_behavior(GameEntity* enemy, GameCoroutineSystem* coroutine_system) {
    while (enemy->is_alive()) {
        // 巡逻状态
        while (enemy->get_state() == PATROL) {
            Vector3 target = enemy->get_next_patrol_point();
            enemy->move_to(target);

            // 等待到达目标点
            co_await WaitUntil([&]() {
                return enemy->distance_to(target) < 0.1f;
            });

            // 等待一段时间
            co_await WaitForSeconds{2.0f};
        }

        // 追击状态
        if (enemy->get_state() == CHASE) {
            auto player = enemy->get_nearest_player();
            if (player) {
                while (enemy->get_state() == CHASE && player->is_alive()) {
                    enemy->move_to(player->get_position());

                    // 检查攻击距离
                    if (enemy->distance_to(player) < 2.0f) {
                        enemy->attack(player);
                        co_await WaitForSeconds{1.0f};
                    }

                    co_await WaitForSeconds{0.1f};
                }
            }
        }
    }
}
```

## 总结与展望

### 关键概念总结

1. **协程基础**：可暂停和恢复的函数，通过三个关键字实现
2. **Promise对象**：管理协程状态、返回值和异常的核心机制
3. **Awaiter机制**：实现协程暂停和恢复的关键组件
4. **异步IO**：协程在网络和文件IO中的重要应用
5. **并发控制**：协程与互斥锁、信号量等同步原语的结合

### 最佳实践建议

1. **合理使用协程**：在IO密集型任务中发挥优势
2. **注意内存管理**：协程栈的生命周期和内存泄漏问题
3. **错误处理**：协程中的异常传播和处理
4. **性能优化**：考虑协程的调度策略和缓存局部性
5. **调试支持**：为协程添加调试和监控功能

### 未来发展趋势

1. **更好的编译器支持**：协程生成代码的优化
2. **标准库扩展**：更多基于协程的标准库组件
3. **框架集成**：游戏引擎、Web框架对协程的深度支持
4. **性能提升**：协程调度和内存管理的进一步优化

C++协程代表了现代异步编程的未来方向，它将复杂的异步操作转化为结构化的同步式写法，极大地提高了代码的可读性和可维护性。通过深入理解协程机制，我们能够编写出高效、优雅的并发程序。

---

*这篇文章全面介绍了C++20协程的核心概念、实现机制和实际应用。通过掌握协程技术，你将能够在异步编程领域写出更加优雅、高效的代码，充分发挥现代多核处理器的计算能力。*